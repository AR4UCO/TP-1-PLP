-- A)
P(e) = cantLit e = S (cantOp e)



-- B)
∀ x :: Float . P(Const x)
∀ x :: Float . ∀ y :: Float . P(Rango x y)

∀ x :: Expr . ∀ y :: Expr . P(x) and P(y) => P(Suma x y)
∀ x :: Expr . ∀ y :: Expr . P(x) and P(y) => P(Resta x y)
∀ x :: Expr . ∀ y :: Expr . P(x) and P(y) => P(Mult x y)
∀ x :: Expr . ∀ y :: Expr . P(x) and P(y) => P(Div x y)




-- C)
Casos Base: 

∀ a :: Float . 
 caso e = Const a:
 Quiero ver que vale P(Const a) =    cantLit (Const a) = S (cantOp (Const a))

       cantLit (Const a) = S (CantOp (Const a))   
 {L1 (lado izq)}     S Z = S (CantOp (Const a))       
 {O1 (lado der)}     S Z = S Z    

Caso base de Const cumple



∀ a :: Float . ∀ b :: Float .
 caso e = Rango a b
 Quiero ver que vale P(Rango a b) =    cantLit (Rango a b) = S (cantOp(Rango a b))

      cantLit (Rango a b) = S (cantOp(Rango a b))
 {L2 (lado izq)}      S Z = S (cantOp(Rango a b))   
 {O2 (lado der)}      S Z = S Z

Caso base de Rango cumple




Paso inductivo:
∀ x :: Expr . ∀ y :: Expr . (cantLit (x) = S (cantOp(x)) and (cantLit (y) = S (cantOp(y)))) => (cantLit (Suma x y) = S (cantOp(Suma x y)))


QVQ vale P(Suma x y) asuminendo P(x) and P(y), donde
    P(x) =    cantLit x = S (cantOp x)
    P(y) =    cantLit y = S (cantOp y)

P(Suma x y)=    cantLit (Suma x y) = S (cantOp(Suma x y))

        	                             cantLit (Suma x y) = S (cantOp(Suma x y))
{L3 (lado izq)}          suma (cantLit x) (cantLit y)       = S (cantOp(Suma x y))
{O3 (lado der)}          suma (cantLit x) (cantLit y)       = S (S (suma (cantOp x) (cantOp y)))
{HI (lado izq)}          suma (S (cantOp x)) (S (cantOp y)) = S (S (suma (cantOp x) (cantOp y)))
{S2 (lado izq)}         S (suma (cantOp x) (S (cantOp y)))  = S (S (suma (cantOp x) (cantOp y)))
{CONMUT (lado izq)}     S (suma (S (cantOp y)) (cantOp x))  = S (S (suma (cantOp x) (cantOp y)))
{S2 (lado izq)}         S (S (suma (cantOp y) (cantOp x)))  = S (S (suma (cantOp x) (cantOp y)))
{CONMUT (lado izq)}     S (S (suma (cantOp x) (cantOp y)))  = S (S (suma (cantOp x) (cantOp y)))

